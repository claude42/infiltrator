Start
* main calls GetPipeline()
* main adds buffer (file) to Pipeline
* main calls ui.Setup()
  * setup creates view (with Pipeline)
    * View calls SetPipeline
      * Adds itself as Event Handler
        * Pipeline triggers Update event directly after
  * Setup asdds Panels
  * sets up Screen
  * windows resize
* Start goes into EventLoop

Resize Event
* Window.Resize() ruft Resize Methode von View auf
  * View setzt Groessen neu und Refreshed ScreenBuffer
* Window.Render() ruft alle Render Methoden der enthaltenen Komponenten auf
* term.Synch()


Potential filters
* keyword filter
* regex filter
* glob filter
* host filter
* date filter
* facility filter

Threads
* main (just waiting)
* FileReader
  * Sends: newLines
  * Receives: ?
* FilterManager
  * Sends: screenUpdated, sizeUpdate, percentage (mb separate thread)
  * Receives from FileReader: newLines
  * Receives from UI: scrollSomewhere, getScreen(really?) addFilter, change mode / case sensitivity, setSize
* UI (runs EventLoop)
  * Receives from FileReader: newLines (to show progress indicator)
  * Receives from FileReader: screenUpdated 




TODO

* Beep
* Display wrong Regex
* Error Messages


* Quit with error message if problems reading file
* Go to end does not update Status bar
Filter mode "ignore/off"
* Status Line
* Line numbering starts with 1
* Update position to first match while entering text into input field
  move backwards when user deletes characters (also when entering
  more characters in "hide" mode)
* consider switching to github.com/hpcloud/tail

* Fail when file can't be opened

* Configuration file
* Change type (Keyword, regex, etc.) on the fly



Events
* EventFileChanged - the contents of a watched file changed (created by Buffer, posted to main event loop)
* EventFilterOutput - filter key, mode or case sensitivity changed filter's output (created by filter, posted to Watchers)

* EventPositionInBuffer - (created by pipieline, posted to watchers)

---

package main

import (
	"fmt"
	"os"
)

func main() {
	// Get information about os.Stdin.
	fileInfo, err := os.Stdin.Stat()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting file info: %v\n", err)
		os.Exit(1)
	}

	// os.ModeCharDevice is the flag for a character device, which is typically a TTY.
	if (fileInfo.Mode() & os.ModeCharDevice) == os.ModeCharDevice {
		fmt.Println("os.Stdin is connected to a terminal (interactive mode).")
		// Your logic for handling a filename from os.Args would go here.
		// e.g. if len(os.Args) < 2 {
		//          fmt.Fprintf(os.Stderr, "less: missing a filename\n")
		//      } else {
		//          // ... open file from os.Args[1]
		//      }

	} else {
		fmt.Println("os.Stdin is connected to a pipe or file (non-interactive mode).")
		// Your Tcell and bufio.Scanner logic to read from stdin would go here.
		// This is where you would use the solution from our previous conversation.
	}
}

func main() {
    // Context that will cancel after 5 seconds if no line is read.
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    lineChan := make(chan string)
    // Goroutine to do the blocking read.
    go func() {
        // scanner.Scan() will block here.
        if scanner.Scan() {
            lineChan <- scanner.Text()
        }
        close(lineChan)
    }()

    select {
    case line := <-lineChan:
        fmt.Println("Received line:", line)
    case <-ctx.Done():
        fmt.Println("Timed out while waiting for a line.")
    }
}


package main

import (
	"fmt"
	"regexp"
)

func main() {
	// The regex pattern.
	syslogPattern := regexp.MustCompile(`^(\w{3}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2})\s+([\w\d\.-]+)\s+([\w\d\.-]+)\[(\d+)?\]:\s+(.+)$`)

	// A typical syslog line.
	logLine := "Aug  8 12:34:56 my-server sshd[12345]: Accepted password for user from 192.0.2.1"

	// Find the submatches.
	matches := syslogPattern.FindStringSubmatch(logLine)

	if len(matches) > 0 {
		fmt.Println("This is a valid syslog line. Components found:")
		fmt.Printf("Timestamp: %s\n", matches[1])
		fmt.Printf("Hostname: %s\n", matches[2])
		fmt.Printf("Application: %s\n", matches[3])
		fmt.Printf("PID: %s\n", matches[4])
		fmt.Printf("Message: %s\n", matches[5])
	} else {
		fmt.Println("The line is not a valid syslog message.")
	}
}


Structure:
* Name / stdin
* File
* Follow
* filters
  * key
  * type
  * mode
  * case-sensitive

  or
  * from
  * to


  package main

import (
    "fmt"
    "log"
    "strings"

    "github.com/knadh/koanf/parsers/toml"
    "github.com/knadh/koanf/v2"
)

// TopLevelConfig mirrors the [Toplevelsomething] table.
type TopLevelConfig struct {
    Name       string `koanf:"name"`
    Filename   string `koanf:"filename"`
    Follow     bool   `koanf:"follow"`
    Linenumber bool   `koanf:"linenumber"`
}

// RegexConfig mirrors one instance of the [[regex]] table array.
type RegexConfig struct {
    Key           string `koanf:"key"`
    Mode          string `koanf:"mode"`
    CaseSensitive bool   `koanf:"casesensitive"`
}

// FullConfig is the top-level struct that contains everything.
type FullConfig struct {
    TopLevel TopLevelConfig `koanf:"Toplevelsomething"`
    Regexes  []RegexConfig  `koanf:"regex"`
    Keywords []RegexConfig  `koanf:"keyword"` // Assuming the same structure.
    Dates    []struct {
        From string `koanf:"from"`
        To   string `koanf:"to"`
    } `koanf:"date"`
}

// Your TOML file content for the example.
const tomlContent = `
[Toplevelsomething]
name = "Meine Abfrage"
filename = "logfile.txt"
follow = false
linenumber = true

[[regex]]
key = "abcd"
mode = "match"
casesensitive = false

[[keyword]]
key = "abcd"
mode = "match"
casesensitive = false

[[date]]
from = "-1d"
to = "-1h"
`

func main() {
    var k = koanf.New(".")
    parser := toml.Parser()
    var config FullConfig

    // Load the TOML content from the string.
    if err := k.Load(strings.NewReader(tomlContent), parser); err != nil {
        log.Fatalf("Error loading config: %v", err)
    }

    // Unmarshal the entire configuration into our struct.
    if err := k.Unmarshal("", &config); err != nil {
        log.Fatalf("Error unmarshalling config: %v", err)
    }

    // Now, you can process the slices with a for...range loop.
    fmt.Printf("Top-level config name: %s\n", config.TopLevel.Name)
    fmt.Println("--------------------")
    
    fmt.Println("Processing Regexes:")
    for _, r := range config.Regexes {
        fmt.Printf("  Key: %s, Mode: %s\n", r.Key, r.Mode)
        // ... call a function for regex ...
    }
    
    fmt.Println("--------------------")

    fmt.Println("Processing Keywords:")
    for _, kw := range config.Keywords {
        fmt.Printf("  Key: %s, Mode: %s\n", kw.Key, kw.Mode)
        // ... call a function for keywords ...
    }
}



package main

import (
	"fmt"
	"log"
	"os"

	"github.com/knadh/koanf/parsers/toml"
	"github.com/knadh/koanf/v2"
)

// FullConfig is the top-level struct that contains all our config.
type FullConfig struct {
	TopLevel struct {
		Name string `koanf:"name"`
		Filename string `koanf:"filename"`
		Follow bool `koanf:"follow"`
	} `koanf:"Toplevelsomething"`
	Regexes  []struct {
		Key string `koanf:"key"`
	} `koanf:"regex"`
	Keywords []struct {
		Key string `koanf:"key"`
	} `koanf:"keyword"`
}

func main() {
	// Step 1: Create and populate the Go struct.
	config := FullConfig{
		TopLevel: struct {
			Name string `koanf:"name"`
			Filename string `koanf:"filename"`
			Follow bool `koanf:"follow"`
		}{
			Name: "Updated Query",
			Filename: "new_log.txt",
			Follow: true,
		},
		Regexes: []struct { Key string `koanf:"key"` }{
			{Key: "^Jun"},
			{Key: "error"},
		},
	}

	var k = koanf.New(".")

	// Step 2: Set the entire struct onto the koanf instance.
	// This is the reverse of Unmarshal.
	if err := k.Set("", config); err != nil {
		log.Fatalf("Error setting config: %v", err)
	}

	// Step 3: Marshal the data back into TOML format.
	marshalledBytes, err := k.Marshal(toml.Parser())
	if err != nil {
		log.Fatalf("Error marshalling to TOML: %v", err)
	}

	// Step 4: Write the byte slice to a file.
	err = os.WriteFile("output.toml", marshalledBytes, 0644)
	if err != nil {
		log.Fatalf("Error writing file: %v", err)
	}

	fmt.Println("Configuration successfully written to output.toml")
}
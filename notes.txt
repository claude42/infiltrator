Start
* main calls GetPipeline()
* main adds buffer (file) to Pipeline
* main calls ui.Setup()
  * setup creates view (with Pipeline)
    * View calls SetPipeline
      * Adds itself as Event Handler
        * Pipeline triggers Update event directly after
  * Setup asdds Panels
  * sets up Screen
  * windows resize
* Start goes into EventLoop

Resize Event
* Window.Resize() ruft Resize Methode von View auf
  * View setzt Groessen neu und Refreshed ScreenBuffer
* Window.Render() ruft alle Render Methoden der enthaltenen Komponenten auf
* term.Synch()


Potential filters
* keyword filter
* regex filter
* glob filter
* host filter
* date filter
* facility filter

Threads
* main (just waiting)
* FileReader
  * Sends: newLines
  * Receives: ?
* FilterManager
  * Sends: screenUpdated, sizeUpdate, percentage (mb separate thread)
  * Receives from FileReader: newLines
  * Receives from UI: scrollSomewhere, getScreen(really?) addFilter, change mode / case sensitivity, setSize
* UI (runs EventLoop)
  * Receives from FileReader: newLines (to show progress indicator)
  * Receives from FileReader: screenUpdated 




TODO
* Beep
* Display wrong Regex
* Error Messages


* ScrollDownBuffer() / ScrollUpBuffer() less weird, more consistent
* Quit with error message if problems reading file
* Go to end does not update Status bar
Filter mode "ignore/off"
* Status Line
* Line numbering starts with 1
* Update position to first match while entering text into input field
  move backwards when user deletes characters (also when entering
  more characters in "hide" mode)
* consider switching to github.com/hpcloud/tail

* Fail when file can't be opened

* Configuration file
* Change type (Keyword, regex, etc.) on the fly



Events
* EventFileChanged - the contents of a watched file changed (created by Buffer, posted to main event loop)
* EventFilterOutput - filter key, mode or case sensitivity changed filter's output (created by filter, posted to Watchers)

* EventPositionInBuffer - (created by pipieline, posted to watchers)

---

package main

import (
	"fmt"
	"os"
)

func main() {
	// Get information about os.Stdin.
	fileInfo, err := os.Stdin.Stat()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting file info: %v\n", err)
		os.Exit(1)
	}

	// os.ModeCharDevice is the flag for a character device, which is typically a TTY.
	if (fileInfo.Mode() & os.ModeCharDevice) == os.ModeCharDevice {
		fmt.Println("os.Stdin is connected to a terminal (interactive mode).")
		// Your logic for handling a filename from os.Args would go here.
		// e.g. if len(os.Args) < 2 {
		//          fmt.Fprintf(os.Stderr, "less: missing a filename\n")
		//      } else {
		//          // ... open file from os.Args[1]
		//      }

	} else {
		fmt.Println("os.Stdin is connected to a pipe or file (non-interactive mode).")
		// Your Tcell and bufio.Scanner logic to read from stdin would go here.
		// This is where you would use the solution from our previous conversation.
	}
}

func main() {
    // Context that will cancel after 5 seconds if no line is read.
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    lineChan := make(chan string)
    // Goroutine to do the blocking read.
    go func() {
        // scanner.Scan() will block here.
        if scanner.Scan() {
            lineChan <- scanner.Text()
        }
        close(lineChan)
    }()

    select {
    case line := <-lineChan:
        fmt.Println("Received line:", line)
    case <-ctx.Done():
        fmt.Println("Timed out while waiting for a line.")
    }
}


package main

import (
	"fmt"
	"regexp"
)

func main() {
	// The regex pattern.
	syslogPattern := regexp.MustCompile(`^(\w{3}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2})\s+([\w\d\.-]+)\s+([\w\d\.-]+)\[(\d+)?\]:\s+(.+)$`)

	// A typical syslog line.
	logLine := "Aug  8 12:34:56 my-server sshd[12345]: Accepted password for user from 192.0.2.1"

	// Find the submatches.
	matches := syslogPattern.FindStringSubmatch(logLine)

	if len(matches) > 0 {
		fmt.Println("This is a valid syslog line. Components found:")
		fmt.Printf("Timestamp: %s\n", matches[1])
		fmt.Printf("Hostname: %s\n", matches[2])
		fmt.Printf("Application: %s\n", matches[3])
		fmt.Printf("PID: %s\n", matches[4])
		fmt.Printf("Message: %s\n", matches[5])
	} else {
		fmt.Println("The line is not a valid syslog message.")
	}
}